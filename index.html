ì´ì „ ìš”ì²­ì—ì„œ ì–¸ê¸‰í•˜ì…¨ë˜ HTML, CSS, JavaScriptë¥¼ í†µí•©í•˜ì—¬ **Tetris ê²Œì„**ì„ êµ¬í˜„í•˜ëŠ” í•˜ë‚˜ì˜ ì½”ë“œë¥¼ ì‘ì„±í•´ ë“œë¦¬ê² ìŠµë‹ˆë‹¤.

ì´ ì½”ë“œëŠ” \*\*HTML5 `<canvas>`\*\*ë¥¼ ì‚¬ìš©í•˜ì—¬ ê²Œì„ ë³´ë“œë¥¼ ë Œë”ë§í•˜ê³ , ê¸°ë³¸ì ì¸ ì›€ì§ì„, íšŒì „, ì¤„ ì œê±° ë¡œì§ì„ í¬í•¨í•˜ê³  ìˆìŠµë‹ˆë‹¤.

ì´ ì½”ë“œë¥¼ `index.html` íŒŒì¼ë¡œ ì €ì¥í•˜ê³  ì›¹ ë¸Œë¼ìš°ì €ì—ì„œ ì—´ì–´ë³´ì„¸ìš”.

### ğŸ•¹ï¸ í†µí•© í…ŒíŠ¸ë¦¬ìŠ¤ ê²Œì„ ì½”ë“œ (HTML, CSS, JavaScript)

```html
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris Game</title>
    <style>
        /* CSS ìŠ¤íƒ€ì¼ ì‹œì‘ */
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #2c3e50;
            color: #ecf0f1;
            font-family: 'Arial', sans-serif;
        }

        .game-container {
            display: flex;
            gap: 20px;
            padding: 20px;
            border-radius: 8px;
            background-color: #34495e;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }

        #board {
            border: 5px solid #bdc3c7;
            background-color: #2c3e50;
        }

        .info-panel {
            width: 150px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .info-box {
            background-color: #2c3e50;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            border: 2px solid #7f8c8d;
        }

        .info-box h3 {
            margin-top: 0;
            color: #f1c40f;
        }

        .info-box p {
            font-size: 1.5em;
            font-weight: bold;
            margin: 5px 0;
        }

        #next-piece-canvas {
            border: 2px solid #7f8c8d;
            background-color: #34495e;
            margin-top: 10px;
        }

        /* CSS ìŠ¤íƒ€ì¼ ë */
    </style>
</head>
<body>

    <h1>ğŸ§± Tetris (í…ŒíŠ¸ë¦¬ìŠ¤) ğŸ§±</h1>

    <div class="game-container">
        <canvas id="board"></canvas>

        <div class="info-panel">
            <div class="info-box">
                <h3>SCORE</h3>
                <p id="score">0</p>
            </div>
            <div class="info-box">
                <h3>NEXT</h3>
                <canvas id="next-piece-canvas"></canvas>
            </div>
            <div class="info-box">
                <h3>LEVEL</h3>
                <p id="level">1</p>
            </div>
        </div>
    </div>

    <p style="margin-top: 20px;">
        **ì¡°ì‘ë²•:** â¬…ï¸ ì¢Œ, â¡ï¸ ìš°, â¬‡ï¸ ì•„ë˜, â¬†ï¸ íšŒì „
    </p>

    <script>
        // JavaScript ë¡œì§ ì‹œì‘

        // 1. ì„¤ì • ë° ì´ˆê¸°í™”
        const COLS = 10; // ì—´ ê°œìˆ˜
        const ROWS = 20; // í–‰ ê°œìˆ˜
        const BLOCK_SIZE = 30; // ë¸”ë¡ í•˜ë‚˜ì˜ í¬ê¸° (í”½ì…€)

        const canvas = document.getElementById('board');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const levelElement = document.getElementById('level');

        // ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì •
        canvas.width = COLS * BLOCK_SIZE;
        canvas.height = ROWS * BLOCK_SIZE;

        // ê²Œì„ ë³€ìˆ˜
        let board = createBoard(); // 2ì°¨ì› ë°°ì—´ ë³´ë“œ
        let currentPiece = null;
        let nextPiece = createPiece();
        let score = 0;
        let level = 1;
        let dropInterval = 1000; // ë¸”ë¡ ë–¨ì–´ì§€ëŠ” ì‹œê°„ (ms)
        let lastTime = 0;
        let gameOver = false;

        // í…ŒíŠ¸ë¡œë¯¸ë…¸ ì •ì˜ (ëª¨ì–‘ê³¼ ìƒ‰ìƒ)
        // 0: ë¹ˆ ê³µê°„
        const SHAPES = [
            // I-Block (Cyan)
            [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]],
            // J-Block (Blue)
            [[2, 0, 0], [2, 2, 2], [0, 0, 0]],
            // L-Block (Orange)
            [[0, 0, 3], [3, 3, 3], [0, 0, 0]],
            // O-Block (Yellow)
            [[4, 4], [4, 4]],
            // S-Block (Green)
            [[0, 5, 5], [5, 5, 0], [0, 0, 0]],
            // T-Block (Purple)
            [[0, 6, 0], [6, 6, 6], [0, 0, 0]],
            // Z-Block (Red)
            [[7, 7, 0], [0, 7, 7], [0, 0, 0]]
        ];

        const COLORS = [
            '#000000', // 0: Background
            '#00FFFF', // 1: I-Block (Cyan)
            '#0000FF', // 2: J-Block (Blue)
            '#FFA500', // 3: L-Block (Orange)
            '#FFFF00', // 4: O-Block (Yellow)
            '#00FF00', // 5: S-Block (Green)
            '#800080', // 6: T-Block (Purple)
            '#FF0000'  // 7: Z-Block (Red)
        ];

        // 2. í•µì‹¬ í•¨ìˆ˜

        /**
         * 10x20 í¬ê¸°ì˜ ë¹ˆ ê²Œì„ ë³´ë“œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
         */
        function createBoard() {
            const matrix = [];
            while (matrix.length < ROWS) {
                matrix.push(new Array(COLS).fill(0));
            }
            return matrix;
        }

        /**
         * ë¬´ì‘ìœ„ë¡œ ìƒˆë¡œìš´ í…ŒíŠ¸ë¡œë¯¸ë…¸ ì¡°ê°ì„ ìƒì„±í•˜ê³  ì´ˆê¸° ìœ„ì¹˜ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤.
         */
        function createPiece() {
            const type = Math.floor(Math.random() * SHAPES.length);
            const shape = SHAPES[type];
            const colorIndex = type + 1; // 1~7 ì‚¬ì´ì˜ ìƒ‰ìƒ ì¸ë±ìŠ¤
            
            return {
                shape: shape,
                colorIndex: colorIndex,
                x: Math.floor(COLS / 2) - Math.floor(shape[0].length / 2),
                y: 0
            };
        }

        /**
         * ë³´ë“œì™€ í˜„ì¬ ì¡°ê°ì„ ìº”ë²„ìŠ¤ì— ê·¸ë¦½ë‹ˆë‹¤.
         */
        function draw() {
            // ë°°ê²½ ê·¸ë¦¬ê¸°
            ctx.fillStyle = COLORS[0]; // ê²€ì€ìƒ‰ ë°°ê²½
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ê³ ì •ëœ ë³´ë“œ ë¸”ë¡ ê·¸ë¦¬ê¸°
            drawMatrix(board, { x: 0, y: 0 });

            // í˜„ì¬ ì›€ì§ì´ëŠ” ì¡°ê° ê·¸ë¦¬ê¸°
            if (currentPiece) {
                drawMatrix(currentPiece.shape, currentPiece);
            }
        }

        /**
         * ì£¼ì–´ì§„ ë§¤íŠ¸ë¦­ìŠ¤(ì¡°ê° ë˜ëŠ” ë³´ë“œ)ë¥¼ ìº”ë²„ìŠ¤ì— ê·¸ë¦½ë‹ˆë‹¤.
         */
        function drawMatrix(matrix, offset) {
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        ctx.fillStyle = COLORS[value];
                        ctx.fillRect(
                            (offset.x + x) * BLOCK_SIZE,
                            (offset.y + y) * BLOCK_SIZE,
                            BLOCK_SIZE,
                            BLOCK_SIZE
                        );
                        // ë¸”ë¡ ê²½ê³„ì„  (ì„ íƒ ì‚¬í•­)
                        ctx.strokeStyle = '#2c3e50';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(
                            (offset.x + x) * BLOCK_SIZE,
                            (offset.y + y) * BLOCK_SIZE,
                            BLOCK_SIZE,
                            BLOCK_SIZE
                        );
                    }
                });
            });
        }

        /**
         * ì¶©ëŒ ê°ì§€ ë¡œì§: í˜„ì¬ ì¡°ê°ì´ ë³´ë“œì˜ ê²½ê³„ë¥¼ ë²—ì–´ë‚˜ê±°ë‚˜ ì´ë¯¸ ê³ ì •ëœ ë¸”ë¡ê³¼ ê²¹ì¹˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
         */
        function collide(board, piece) {
            const [matrix, x, y] = [piece.shape, piece.x, piece.y];
            for (let r = 0; r < matrix.length; r++) {
                for (let c = 0; c < matrix[r].length; c++) {
                    if (matrix[r][c] !== 0) {
                        // 1. ë³´ë“œì˜ ê²½ê³„ë¥¼ ë²—ì–´ë‚˜ëŠ”ê°€? (ì¢Œ/ìš°/í•˜ë‹¨)
                        // 2. ë³´ë“œì— ì´ë¯¸ ë¸”ë¡ì´ ìˆëŠ” ìœ„ì¹˜ì¸ê°€?
                        if (
                            c + x < 0 || // ì™¼ìª½ ê²½ê³„
                            c + x >= COLS || // ì˜¤ë¥¸ìª½ ê²½ê³„
                            r + y >= ROWS || // ì•„ë˜ìª½ ê²½ê³„
                            (r + y >= 0 && board[r + y][c + x] !== 0) // ê¸°ì¡´ ë¸”ë¡ê³¼ ì¶©ëŒ
                        ) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        /**
         * í˜„ì¬ ì¡°ê°ì„ ë³´ë“œì— ë³‘í•©(ê³ ì •)ì‹œí‚µë‹ˆë‹¤.
         */
        function merge(board, piece) {
            piece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        board[piece.y + y][piece.x + x] = value;
                    }
                });
            });
            updateScoreAndLevel();
        }

        /**
         * ì¡°ê°ì„ í•œ ì¹¸ ì•„ë˜ë¡œ ë–¨ì–´ëœ¨ë¦½ë‹ˆë‹¤.
         */
        function dropPiece() {
            if (gameOver) return;
            currentPiece.y++;
            if (collide(board, currentPiece)) {
                currentPiece.y--; // ì¶©ëŒí–ˆìœ¼ë¯€ë¡œ í•œ ì¹¸ ìœ„ë¡œ ë˜ëŒë¦¬ê¸°
                merge(board, currentPiece);
                clearLines();
                
                // ë‹¤ìŒ ì¡°ê° ìƒì„± ë° ê²Œì„ ì˜¤ë²„ ì²´í¬
                currentPiece = nextPiece;
                nextPiece = createPiece();
                drawNextPiece();
                
                // ìƒˆë¡œìš´ ì¡°ê°ì´ ìƒì„±ë˜ìë§ˆì ì¶©ëŒí•˜ë©´ ê²Œì„ ì˜¤ë²„
                if (collide(board, currentPiece)) {
                    gameOver = true;
                    alert(`Game Over! ìµœì¢… ì ìˆ˜: ${score}`);
                }
            }
        }

        /**
         * ì™„ì„±ëœ ì¤„ì„ ì°¾ê³  ì œê±°í•œ í›„ ì ìˆ˜ë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
         */
        function clearLines() {
            let linesCleared = 0;
            outer: for (let y = ROWS - 1; y >= 0; y--) {
                for (let x = 0; x < COLS; x++) {
                    if (board[y][x] === 0) {
                        continue outer; // ì´ ì¤„ì€ ì™„ì„±ë˜ì§€ ì•Šì•˜ìœ¼ë¯€ë¡œ ë‹¤ìŒ ì¤„ë¡œ ì´ë™
                    }
                }
                
                // ì¤„ ì™„ì„±!
                linesCleared++;
                const row = board.splice(y, 1)[0].fill(0); // ì™„ì„±ëœ ì¤„ ì œê±°
                board.unshift(row); // ë§¨ ìœ„ì— ë¹ˆ ì¤„ ì¶”ê°€
                y++; // ì¤„ì´ ë‚´ë ¤ì™”ìœ¼ë¯€ë¡œ í˜„ì¬ ì¤„ì„ ë‹¤ì‹œ ê²€ì‚¬
            }
            
            // ì ìˆ˜ ê³„ì‚° (Tetris ê³µì‹ ì‚¬ìš©)
            if (linesCleared > 0) {
                const points = [0, 40, 100, 300, 1200][linesCleared];
                score += points * level; // ë ˆë²¨ì— ë”°ë¼ ì ìˆ˜ ê°€ì¤‘ì¹˜
            }
        }
        
        /**
         * ì ìˆ˜ì™€ ë ˆë²¨ì„ ì—…ë°ì´íŠ¸í•˜ê³ , ë ˆë²¨ì— ë”°ë¼ ë–¨ì–´ì§€ëŠ” ì†ë„ë¥¼ ì¡°ì •í•©ë‹ˆë‹¤.
         */
        function updateScoreAndLevel() {
            scoreElement.textContent = score;

            // ë‹¨ìˆœí™”ëœ ë ˆë²¨ì—… ì¡°ê±´ (ì˜ˆ: 1000ì ë§ˆë‹¤ ë ˆë²¨ì—…)
            const newLevel = Math.floor(score / 1000) + 1;
            if (newLevel > level) {
                level = newLevel;
                levelElement.textContent = level;
                dropInterval = Math.max(100, 1000 - (level - 1) * 100); // ìµœì†Œ 100ms
            }
        }


        /**
         * ì¡°ê°ì„ íšŒì „ì‹œí‚µë‹ˆë‹¤. (ì‹œê³„ ë°©í–¥)
         */
        function rotate(piece) {
            // í–‰ë ¬ ì „ì¹˜ (Transpose)
            for (let y = 0; y < piece.shape.length; ++y) {
                for (let x = 0; x < y; ++x) {
                    [
                        piece.shape[x][y],
                        piece.shape[y][x],
                    ] = [
                        piece.shape[y][x],
                        piece.shape[x][y],
                    ];
                }
            }

            // í–‰ ë°˜ì „ (Reverse rows)
            piece.shape.forEach(row => row.reverse());
        }

        /**
         * íšŒì „ ì‹œ ë²½ì— ë¼ì´ëŠ” ê²ƒì„ ë°©ì§€í•˜ê¸° ìœ„í•´ ìœ„ì¹˜ë¥¼ ì¡°ì •í•©ë‹ˆë‹¤.
         */
        function rotatePiece() {
            const originalX = currentPiece.x;
            let offset = 1;
            
            rotate(currentPiece);
            
            // Wall Kick (ë²½ì°¨ê¸°) êµ¬í˜„ (ê°„ì†Œí™” ë²„ì „)
            while (collide(board, currentPiece)) {
                currentPiece.x += offset;
                offset = -(offset + (offset > 0 ? 1 : -1));
                // ë„ˆë¬´ ë§ì´ ì´ë™í•˜ë©´ íšŒì „ì„ ì·¨ì†Œí•©ë‹ˆë‹¤.
                if (offset > currentPiece.shape[0].length) {
                    // íšŒì „ì„ 3ë²ˆ ë”í•˜ì—¬ ì›ë˜ ëª¨ì–‘ìœ¼ë¡œ ë˜ëŒë¦½ë‹ˆë‹¤. (ì´ 4íšŒì „)
                    rotate(currentPiece); 
                    rotate(currentPiece);
                    rotate(currentPiece);
                    currentPiece.x = originalX;
                    return;
                }
            }
        }
        
        /**
         * ë‹¤ìŒ ì¡°ê° ë¯¸ë¦¬ë³´ê¸° ìº”ë²„ìŠ¤ì— ê·¸ë¦¬ê¸°
         */
        function drawNextPiece() {
            const nextCanvas = document.getElementById('next-piece-canvas');
            const nextCtx = nextCanvas.getContext('2d');
            
            // ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì • (ëŒ€ë¶€ë¶„ì˜ ì¡°ê°ì´ 3x3ì´ë¯€ë¡œ 4x4 í¬ê¸°ë¡œ ì„¤ì •)
            const nextSize = 4;
            nextCanvas.width = nextSize * BLOCK_SIZE / 2;
            nextCanvas.height = nextSize * BLOCK_SIZE / 2;

            nextCtx.fillStyle = '#34495e'; // ë°°ê²½ìƒ‰
            nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);

            const matrix = nextPiece.shape;
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        nextCtx.fillStyle = COLORS[value];
                        // ë¯¸ë¦¬ë³´ê¸° ìº”ë²„ìŠ¤ì—ì„œëŠ” í¬ê¸°ë¥¼ ì ˆë°˜ìœ¼ë¡œ ì¤„ì—¬ì„œ ê·¸ë¦½ë‹ˆë‹¤.
                        nextCtx.fillRect(
                            x * (BLOCK_SIZE / 2),
                            y * (BLOCK_SIZE / 2),
                            BLOCK_SIZE / 2,
                            BLOCK_SIZE / 2
                        );
                        nextCtx.strokeStyle = '#2c3e50';
                        nextCtx.lineWidth = 1;
                        nextCtx.strokeRect(
                            x * (BLOCK_SIZE / 2),
                            y * (BLOCK_SIZE / 2),
                            BLOCK_SIZE / 2,
                            BLOCK_SIZE / 2
                        );
                    }
                });
            });
        }


        // 3. ê²Œì„ ë£¨í”„ ë° ì´ë²¤íŠ¸ ì²˜ë¦¬

        /**
         * ë©”ì¸ ê²Œì„ ë£¨í”„ (ì• ë‹ˆë©”ì´ì…˜)
         */
        function update(time = 0) {
            if (gameOver) return;

            const deltaTime = time - lastTime;
            lastTime = time;

            // ì¼ì • ì‹œê°„ì´ ì§€ë‚˜ë©´ ë¸”ë¡ì„ ë–¨ì–´ëœ¨ë¦½ë‹ˆë‹¤.
            if (deltaTime > dropInterval) {
                dropPiece();
                lastTime = time; // ë“œë¡­ í›„ ì‹œê°„ ì´ˆê¸°í™”
            }

            draw(); // í™”ë©´ ê·¸ë¦¬ê¸°
            requestAnimationFrame(update); // ë‹¤ìŒ í”„ë ˆì„ ìš”ì²­
        }

        /**
         * í‚¤ë³´ë“œ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
         */
        document.addEventListener('keydown', event => {
            if (gameOver) return;

            switch (event.key) {
                case 'ArrowLeft': // ì™¼ìª½
                    currentPiece.x--;
                    if (collide(board, currentPiece)) {
                        currentPiece.x++; // ì¶©ëŒí•˜ë©´ ë˜ëŒë¦¬ê¸°
                    }
                    break;
                case 'ArrowRight': // ì˜¤ë¥¸ìª½
                    currentPiece.x++;
                    if (collide(board, currentPiece)) {
                        currentPiece.x--;
                    }
                    break;
                case 'ArrowDown': // ì•„ë˜ (ë¹¨ë¦¬ ë–¨ì–´ëœ¨ë¦¬ê¸°)
                    dropPiece();
                    break;
                case 'ArrowUp': // íšŒì „
                    rotatePiece();
                    break;
            }
        });

        // 4. ê²Œì„ ì‹œì‘
        currentPiece = createPiece();
        drawNextPiece();
        update(); // ê²Œì„ ë£¨í”„ ì‹œì‘

        // JavaScript ë¡œì§ ë
    </script>

</body>
</html>
```
